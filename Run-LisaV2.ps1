##############################################################################################
# Run-LisaV2.ps1
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License.
#
<#
.SYNOPSIS
	This is the entrance script for LISAv2.
	LISAv2 is the test framework running Linux test automation on Azure and HyperV platforms,
	including remote test launching in dev system.

.PARAMETER
	See source code for the detailed parameters

.NOTES
	PREREQUISITES:
	1) Prepare necessary 3rd party tools and put them into the Tools folder;
	2) Review the XML configuration files under XML folder and make necessary change for your environment.
	See more from https://github.com/LIS/LISAv2 for helps including README and How-to-use document.

.EXAMPLE
	.\Run-LisaV2.ps1	-TestPlatform "Azure" -TestLocation "westus2" -RGIdentifier "mylisatest"
					-ARMImageName "Canonical UbuntuServer 16.04-LTS latest"
					-XMLSecretFile "C:\MySecrets.xml"
					-TestNames "BVT-VERIFY-DEPLOYMENT-PROVISION"

	.\Run-LisaV2.ps1 -ParametersFile .\XML\TestParameters.xml
	Note: Please refer .\XML\TestParameters.xml file for more details.

#>
###############################################################################################

[CmdletBinding()]
Param(
	#Do not use. Reserved for Jenkins use.
	$BuildNumber=$env:BUILD_NUMBER,

	#[Optional]
	[string] $ParametersFile = "",

	#[Required]
	[ValidateSet('Azure','HyperV', IgnoreCase = $false)]
	[string] $TestPlatform = "",

	#[Required] for Azure.
	[string] $TestLocation="",
	[string] $ARMImageName = "",
	[string] $StorageAccount="",

	#[Required] for HyperV
	[string] $SourceOsVHDPath="",

	#[Required] for Two Hosts HyperV
	[string] $DestinationOsVHDPath="",

	#[Required] Common for HyperV and Azure.
	[string] $RGIdentifier = "",
	[string] $OsVHD = "",   #... [Azure: Required only if -ARMImageName is not provided.]
							#... [HyperV: Mandatory]
	[string] $TestCategory = "",
	[string] $TestArea = "",
	[string] $TestTag = "",
	[string] $TestNames="",
	[string] $TestPriority="",

	#[Optional] Parameters for Image preparation before running tests.
	[string] $CustomKernel = "",
	[string] $CustomLIS,

	#[Optional] Parameters for changing framework behavior.
	[int]    $TestIterations,
	[string] $TiPSessionId,
	[string] $TiPCluster,
	[string] $XMLSecretFile = "",
	[switch] $EnableTelemetry,

	#[Optional] Parameters for Overriding VM Configuration.
	[string] $CustomParameters = "",
	[string] $OverrideVMSize = "",
	[switch] $EnableAcceleratedNetworking,
	[string] $OverrideHyperVDiskMode = "",
	[switch] $ForceDeleteResources,
	[switch] $UseManagedDisks,
	[switch] $DoNotDeleteVMs,
	[switch] $DeployVMPerEachTest,
	[string] $VMGeneration = "",

	[string] $ResultDBTable = "",
	[string] $ResultDBTestTag = "",

	[switch] $ExitWithZero
)

# Import the Functions from Library Files.
Get-ChildItem .\Libraries -Recurse | Where-Object { $_.FullName.EndsWith(".psm1") } | `
	ForEach-Object { Import-Module $_.FullName -Force -Global -DisableNameChecking }

try {
	$TestID = "{0}{1}" -f $(-join ((65..90) | Get-Random -Count 4 | ForEach-Object {[char]$_})), $(Get-Random -Maximum 99999 -Minimum 11111)
	$LogFileName = "LISAv2-Test-$TestID.log"
	Set-Variable -Name LogFileName -Value $LogFileName -Scope Global -Force
	Set-Variable -Name "TestID" -Value $TestID -Scope Global -Force
	Write-LogInfo "Autogenerated test ID: $TestID"

	# Prepare the workspace
	$MaxDirLength = 32
	$WorkingDirectory = Split-Path -parent $MyInvocation.MyCommand.Definition
	if ( $WorkingDirectory.Length -gt $MaxDirLength) {
		$OriginalWorkingDirectory = $WorkingDirectory
		$WorkingDirectory = Move-ToNewWorkingSpace $OriginalWorkingDirectory | Select-Object -Last 1
	}
	Set-Variable -Name WorkingDirectory -Value $WorkingDirectory  -Scope Global

	# Prepare log folder
	$LogDir = Join-Path $WorkingDirectory "TestResults\$(Get-Date -Format 'yyyy-dd-MM-HH-mm-ss-ffff')"
	Set-Variable -Name LogDir      -Value $LogDir      -Scope Global -Force
	New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
	Write-LogInfo "Logging directory: $LogDir"

	# Import parameters from file if -ParametersFile is given, and set them as global variables
	if ($ParametersFile) {
		Import-TestParameters -ParametersFile $ParametersFile
	}
	# Processing parameters provided in the command runtime
	$paramList = (Get-Command -Name $PSCmdlet.MyInvocation.InvocationName).Parameters;
	foreach ($paramName in $paramList.Keys) {
		$paramObject = Get-Variable -Name $paramName -Scope Script -ErrorAction SilentlyContinue
		$paramValue = $paramObject.Value
		if (($null -ne $paramValue) -and ("" -ne $paramValue)) {
			$paramExistingObject = Get-Variable -Name $paramName -Scope Global -ErrorAction SilentlyContinue
			if ($null -ne $paramExistingObject) {
				$paramExistingValue = $paramExistingObject.Value
				if (($null -ne $paramExistingValue) -and ("" -ne $paramExistingValue) -and ($paramValue -ne $paramExistingValue)) {
					Write-LogInfo "Redefining global variables from test params: $paramName = $paramValue (was $paramExistingValue)"
				}
			}
			Set-Variable -Name $paramName -Value $paramValue -Scope Global -Force
		}
	}
	# Change the value of Local variable to the same value of the the corresponding Global variable
	$GlobalVariables = Get-Variable -Scope Global -ErrorAction SilentlyContinue
	foreach ($var in $GlobalVariables) {
		[void](Set-Variable -Name $var.Name -Value $var.Value -Scope Local -ErrorAction SilentlyContinue)
	}
	# Validate the test parameters.
	Validate-Parameters

	# Validate all the XML files and then import test cases from them for test
	Validate-XmlFiles -ParentFolder $WorkingDirectory
	$TestConfigurationXmlFile = "$WorkingDirectory\TestConfiguration.xml"
	Import-TestCases $WorkingDirectory $TestConfigurationXmlFile
	# Inject default / custom replaceable test parameters to TestConfiguration.xml
	$ReplaceableTestParameters = [xml](Get-Content -Path "$WorkingDirectory\XML\Other\ReplaceableTestParameters.xml")
	Inject-CustomTestParameters $CustomParameters $ReplaceableTestParameters $TestConfigurationXmlFile

	# Handle the Secrets file
	if ($env:Azure_Secrets_File) {
		$XMLSecretFile = $env:Azure_Secrets_File
		Write-LogInfo "The Secrets file is defined by an environment variable."
	}
	if ($XMLSecretFile -ne [string]::Empty) {
		if ((Test-Path -Path $XMLSecretFile) -eq $true) {
			$xmlSecrets = ([xml](Get-Content $XMLSecretFile))
			Set-Variable -Value $xmlSecrets -Name XmlSecrets -Scope Global -Force

			# Download the tools required for LISAv2 execution.
			Get-LISAv2Tools -XMLSecretFile $XMLSecretFile

			# Update the configuration files based on the settings in the XMLSecretFile
			Update-GlobalConfigurationXML $XMLSecretFile
			Update-XMLStringsFromSecretsFile $XMLSecretFile

			if ($TestPlatform -eq "Azure") {
				.\Utilities\AddAzureRmAccountFromSecretsFile.ps1 -customSecretsFilePath $XMLSecretFile
			}
		} else {
			Write-LogErr "The Secret file provided: $XMLSecretFile does not exist"
		}
	} else {
		Write-LogErr "Failed to update configuration files. '-XMLSecretFile [FilePath]' is not provided."
	}

	# Create report folder
	$reportFolder = "$pwd/Report"
	if(!(Test-Path $reportFolder)) {
		New-Item -ItemType "Directory" $reportFolder | Out-Null
	}
	$TestReportXml = Join-Path "$reportFolder" "LISAv2_TestReport_$TestID.xml"

	$command = ".\AutomationManager.ps1 -xmlConfigFile '$TestConfigurationXmlFile' -cycleName 'TC-$TestID' -RGIdentifier '$RGIdentifier' -TestReportXmlPath $TestReportXml"
	# Override VM #
	if ( $OverrideVMSize ) { $command += " -OverrideVMSize $OverrideVMSize" }
	if ( $EnableAcceleratedNetworking ) { $command += " -EnableAcceleratedNetworking" }
	if ( $UseManagedDisks ) {	$command += " -UseManagedDisks" }
	# Override Kernel or LIS #
	if ( $CustomKernel) { $command += " -CustomKernel '$CustomKernel'" }
	if ( $CustomLIS) { $command += " -CustomLIS $CustomLIS" }
	# Override Test Behaviors #
	if ( $TestIterations -gt 1 ) { $command += " -TestIterations $TestIterations" }
	if ( $ForceDeleteResources ) { $command += " -ForceDeleteResources" }
	if ( $DoNotDeleteVMs ) { $command += " -DoNotDeleteVMs" }
	if ( $DeployVMPerEachTest ) { $command += " -DeployVMPerEachTest" }
	# Override for TiP #
	if ( $TiPSessionId) { $command += " -TiPSessionId $TiPSessionId" }
	if ( $TiPCluster) { $command += " -TiPCluster $TiPCluster" }
	# Attaching Secret file if provided #
	if ( $XMLSecretFile ) { $command += " -XMLSecretFile '$XMLSecretFile'" }

	Write-LogInfo $command

	Invoke-Expression -Command $command

	$zipFile = "$TestPlatform"
	if ( $TestCategory ) { $zipFile += "-$TestCategory"	}
	if ( $TestArea ) { $zipFile += "-$TestArea" }
	if ( $TestTag ) { $zipFile += "-$($TestTag)" }
	if ( $TestPriority ) { $zipFile += "-$($TestPriority)" }
	$zipFile += "-$TestID-TestLogs.zip"
	$zipFile = $zipFile.Replace("*", "All")
	New-ZipFile -zipFileName $zipFile -sourceDir $LogDir

	$reportXmlJUnit = $TestReportXml.Replace(".xml", "-junit.xml")
	if (Test-Path -Path $TestReportXml ) {
		Copy-Item -Path $TestReportXml -Destination $reportXmlJUnit -Force -ErrorAction SilentlyContinue
		Write-LogInfo "Copied : $TestReportXml --> $reportXmlJUnit"
		Write-LogInfo "Analyzing results.."
		$resultXML = [xml](Get-Content $TestReportXml -ErrorAction SilentlyContinue)
		Write-LogInfo "PASS  : $($resultXML.testsuites.testsuite.tests - $resultXML.testsuites.testsuite.errors - $resultXML.testsuites.testsuite.failures)"
		Write-LogInfo "FAIL  : $($resultXML.testsuites.testsuite.failures)"
		Write-LogInfo "ABORT : $($resultXML.testsuites.testsuite.errors)"
		if ( ( $resultXML.testsuites.testsuite.failures -eq 0 ) -and ( $resultXML.testsuites.testsuite.errors -eq 0 ) -and ( $resultXML.testsuites.testsuite.tests -gt 0 )) {
			$ExitCode = 0
		} else {
			$ExitCode = 1
		}
	} else {
		Write-LogErr "Summary file: $TestReportXml does not exist. Exiting with ErrorCode 1."
		$ExitCode = 1
	}
} catch {
	$line = $_.InvocationInfo.ScriptLineNumber
	$script_name = ($_.InvocationInfo.ScriptName).Replace($PWD,".")
	$ErrorMessage =  $_.Exception.Message

	Write-LogErr "EXCEPTION : $ErrorMessage"
	Write-LogErr "Source : Line $line in script $script_name."
	$ExitCode = 1
} finally {
	if ($OriginalWorkingDirectory) {
		Move-BackToOriginalWorkingSpace $WorkingDirectory $OriginalWorkingDirectory $ExitCode
	}
	if ( $ExitWithZero -and ($ExitCode -ne 0) ) {
		Write-LogInfo "Suppress the exit code from $ExitWithZero to 0. (-ExitWithZero specified in command line)"
		$ExitCode = 0
	}
	Get-Variable -Exclude PWD,*Preference,ExitCode | Remove-Variable -Force -ErrorAction SilentlyContinue
	Write-LogInfo "LISAv2 exit code: $ExitCode"

	exit $ExitCode
}
